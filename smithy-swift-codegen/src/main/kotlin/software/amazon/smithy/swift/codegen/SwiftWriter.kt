/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0.
 */

package software.amazon.smithy.swift.codegen

import software.amazon.smithy.codegen.core.CodegenException
import software.amazon.smithy.codegen.core.Symbol
import software.amazon.smithy.codegen.core.SymbolReference
import software.amazon.smithy.codegen.core.SymbolWriter
import software.amazon.smithy.model.Model
import software.amazon.smithy.model.loader.Prelude
import software.amazon.smithy.model.shapes.MemberShape
import software.amazon.smithy.model.shapes.Shape
import software.amazon.smithy.model.traits.DeprecatedTrait
import software.amazon.smithy.model.traits.DocumentationTrait
import software.amazon.smithy.model.traits.EnumDefinition
import software.amazon.smithy.model.traits.RequiredTrait
import software.amazon.smithy.swift.cod.DocumentationConverter
import software.amazon.smithy.swift.codegen.integration.SectionId
import software.amazon.smithy.swift.codegen.integration.SectionWriter
import software.amazon.smithy.swift.codegen.integration.SwiftIntegration
import software.amazon.smithy.swift.codegen.model.SymbolProperty
import software.amazon.smithy.swift.codegen.model.defaultValue
import software.amazon.smithy.swift.codegen.model.defaultValueFromClosure
import software.amazon.smithy.swift.codegen.model.isBoxed
import software.amazon.smithy.swift.codegen.model.isBuiltIn
import software.amazon.smithy.swift.codegen.model.isGeneric
import software.amazon.smithy.swift.codegen.model.isOptional
import software.amazon.smithy.swift.codegen.model.isServiceNestedNamespace
import java.util.function.BiFunction
import kotlin.jvm.optionals.getOrElse
import kotlin.jvm.optionals.getOrNull

/**
 * Handles indenting follow on params to a function that takes several params or a builder object
 * i.e.
 * func test(param1: String, param2: String, param3: Int)
 *
 * test(param1: "hi",
 *      param2: "test",
 *      param3: 4)
 */
fun SwiftWriter.swiftFunctionParameterIndent(block: SwiftWriter.() -> Unit): SwiftWriter {
    this.indent(3)
    block(this)
    this.dedent(3)
    return this
}

fun SwiftWriter.declareSection(
    id: SectionId,
    context: Map<String, Any?> = emptyMap(),
    block: SwiftWriter.() -> Unit = {},
): SwiftWriter {
    putContext(context)
    pushState(id.javaClass.canonicalName)
    block(this)
    popState()
    removeContext(context)
    return this
}

private fun SwiftWriter.removeContext(context: Map<String, Any?>): Unit = context.keys.forEach { key -> removeContext(key) }

fun SwiftWriter.customizeSection(
    id: SectionId,
    writer: SectionWriter,
): SwiftWriter {
    onSection(id.javaClass.canonicalName) { default ->
        require(default is String?) { "Expected Smithy to pass String for previous value but found ${default::class.java}" }
        writer.write(this, default)
    }
    return this
}

class SwiftWriter(
    private val fullPackageName: String,
    private val copyrightNotice: String = "// Code generated by smithy-swift-codegen. DO NOT EDIT!\n\n",
    swiftImportContainer: SwiftImportContainer = SwiftImportContainer(),
) : SymbolWriter<SwiftWriter, SwiftImportContainer>(swiftImportContainer) {
    companion object {
        const val SWIFT_FILE_EXTENSION: String = ".swift"
    }

    class SwiftWriterFactory(
        private val integrations: List<SwiftIntegration> = listOf(),
        private val settings: SwiftSettings,
    ) : Factory<SwiftWriter> {
        override fun apply(
            filename: String,
            namespace: String?,
        ): SwiftWriter {
            val moduleName =
                if (filename.endsWith(SWIFT_FILE_EXTENSION)) {
                    filename.substring(0, filename.length - 6)
                } else {
                    filename
                }

            val swiftWriter = SwiftWriter(moduleName, settings.copyrightNotice)

            integrations.forEach { integration ->
                integration.sectionWriters.forEach { (sectionId, sectionWriter) ->
                    swiftWriter.customizeSection(sectionId) { codeWriter, previousValue ->
                        sectionWriter.write(codeWriter, previousValue)
                    }
                }
            }

            return swiftWriter
        }
    }

    fun addImport(symbol: Symbol) {
        symbol.references.forEach { addImport(it.symbol) }
        if (symbol.isBuiltIn || symbol.isServiceNestedNamespace || symbol.namespace.isEmpty()) return
        val spiNames = symbol.getProperty("spiNames").getOrElse { emptyList<String>() } as List<String>
        val decl = symbol.getProperty("decl").getOrNull()?.toString()
        decl?.let {
            // No need to import Foundation types individually because:
            // - Foundation is always present on supported platforms & needs not be managed as a dependency.
            // - Importing Foundation types individually becomes messy when swift-corelibs-foundation
            //   splits them out to separate modules like FoundationXML or FoundationNetworking.
            //
            // SwiftWriter does not manage swift-corelibs-foundation imports; the source files that access
            // those types should import FoundationXML, FoundationNetworking, or other corelibs module
            // by calling the function below.
            if (symbol.namespace == "Foundation") {
                addImport(symbol.namespace)
            } else {
                addImport("$it ${symbol.namespace}.${symbol.name}", internalSPINames = spiNames)
            }
        } ?: run {
            addImport(symbol.namespace, internalSPINames = spiNames)
        }
        symbol.dependencies.forEach { addDependency(it) }
        val additionalImports = symbol.getProperty("additionalImports").getOrElse { emptyList<Symbol>() } as List<Symbol>
        additionalImports.forEach { addImport(it) }
    }

    fun addImport(
        packageName: String,
        isTestable: Boolean = false,
        internalSPINames: List<String> = emptyList(),
        importOnlyIfCanImport: Boolean = false,
    ) {
        importContainer.addImport(packageName, isTestable, internalSPINames, importOnlyIfCanImport)
    }

    fun addImportReferences(
        symbol: Symbol,
        vararg options: SymbolReference.ContextOption,
    ) {
        symbol.references.forEach { reference ->
            for (option in options) {
                if (reference.hasOption(option)) {
                    addImport(reference.symbol)
                    break
                }
            }
        }
    }

    override fun toString(): String {
        val contents = super.toString()
        val imports = "${importContainer}\n\n"

        // Leave out the header and imports for a Swift package manifest (Package.swift).
        // Package.swift requires a special comment at the top to specify Swift tools version,
        // and the package manifest generator manually writes its own dependency imports
        // (it only imports the PackageDescription module.)
        //
        // Also leave out the headers when JSON or the version file is being written,
        // as indicated by the file extension.
        val isPackageManifest = listOf(PACKAGE_MANIFEST_NAME, (PACKAGE_MANIFEST_NAME + ".swift")).contains(fullPackageName)
        val isNonSwiftSourceFile = listOf(".json", ".version").any { fullPackageName.endsWith(it) }
        val noHeader = isPackageManifest || isNonSwiftSourceFile
        return contents.takeIf { noHeader } ?: (copyrightNotice + imports + contents)
    }

    private class SwiftSymbolFormatter(
        val writer: SwiftWriter,
        val shouldSetDefault: Boolean,
        val shouldRenderOptional: Boolean,
    ) : BiFunction<Any, String, String> {
        override fun apply(
            type: Any,
            indent: String,
        ): String {
            when (type) {
                is Symbol -> {
                    writer.addImport(type)
                    var formatted = type.fullName
                    if (type.isBoxed() && shouldRenderOptional) {
                        formatted += "?"
                    }

                    if (type.isGeneric() && type.isOptional()) {
                        formatted = "(any $formatted)?"
                    } else if (type.isGeneric()) {
                        formatted = "any $formatted"
                    } else if (type.isOptional()) {
                        formatted = "$formatted?"
                    }

                    if (shouldSetDefault) {
                        getDefaultValue(type)?.let {
                            formatted += " = $it"
                        }
                    }

                    return formatted
                }
                else -> throw CodegenException("Invalid type provided for \$T. Expected a Symbol, but found `$type`")
            }
        }

        private fun getDefaultValue(symbol: Symbol): String? =
            if (symbol.properties.containsKey(SymbolProperty.DEFAULT_VALUE_CLOSURE_KEY)) {
                symbol.defaultValueFromClosure(writer)
            } else {
                symbol.defaultValue()
            }
    }

    /**
     * Configures the writer with the appropriate single-line doc comment and calls the [block]
     * with this writer. Any calls to `write()` inside of block will be escaped appropriately.
     * On return the writer's original state is restored.
     *
     * e.g.
     * ```
     * writer.writeSingleLineDocs() {
     *     write("This is a single-line doc comment")
     * }
     * ```
     *
     * would output
     *
     * ```
     * /// This is a single-line doc comment
     * ```
     */
    fun writeSingleLineDocs(block: SwiftWriter.() -> Unit) {
        pushState("singleLineDocs")
        setNewlinePrefix("/// ")
        block(this)
        popState()
    }

    fun writeDocs(docs: String) {
        val convertedDocs = DocumentationConverter.convert(docs)
        writeSingleLineDocs {
            write(convertedDocs)
        }
    }

    /**
     * Writes shape documentation comments if docs are present.
     */
    fun writeShapeDocs(shape: Shape) {
        shape.getTrait(DocumentationTrait::class.java).ifPresent {
            writeDocs(it.value)
        }
    }

    /*
     * Writes @available attribute if deprecated trait is present
     * */
    fun writeAvailableAttribute(
        model: Model?,
        shape: Shape,
    ) {
        var deprecatedTrait: DeprecatedTrait? = null
        if (shape.getTrait(DeprecatedTrait::class.java).isPresent) {
            deprecatedTrait = shape.getTrait(DeprecatedTrait::class.java).get()
        } else if (shape.getMemberTrait(model, DeprecatedTrait::class.java).isPresent) {
            if (shape is MemberShape) {
                if (!Prelude.isPreludeShape(shape.getTarget())) {
                    deprecatedTrait = shape.getMemberTrait(model, DeprecatedTrait::class.java).get()
                }
            } else {
                deprecatedTrait = shape.getMemberTrait(model, DeprecatedTrait::class.java).get()
            }
        }

        if (deprecatedTrait != null) {
            val messagePresent = deprecatedTrait.message.isPresent
            val sincePresent = deprecatedTrait.since.isPresent
            var message = StringBuilder()
            if (messagePresent) {
                message.append(deprecatedTrait.message.get())
            }
            if (sincePresent) {
                val conditionalSpace = if (messagePresent) " " else ""
                message.append("${conditionalSpace}API deprecated since ${deprecatedTrait.since.get()}")
            }

            if (messagePresent || sincePresent) {
                write("@available(*, deprecated, message: \"${message}\")")
            } else {
                write("@available(*, deprecated)")
            }
        }
    }

    /**
     * Writes member shape documentation comments if docs are present.
     */
    fun writeMemberDocs(
        model: Model,
        member: MemberShape,
    ) {
        member.getMemberTrait(model, DocumentationTrait::class.java).orElse(null)?.let { writeDocs(it.value) }
        member
            .getMemberTrait(
                model,
                RequiredTrait::class.java,
            ).orElse(null)
            ?.let { writeDocs("This member is required.") }
    }

    /**
     * Writes documentation comments for Enum Definitions if present.
     */
    fun writeEnumDefinitionDocs(enumDefinition: EnumDefinition) {
        enumDefinition.documentation.ifPresent {
            writeDocs(it)
        }
    }

    fun indent(function: () -> Unit) {
        indent()
        function()
        dedent()
    }

    init {
        trimBlankLines()
        trimTrailingSpaces()
        setIndentText("    ")
        // Default values and optionality can be configured for a symbol (See SymbolBuilder)
        // The following custom formatters will render symbols according to its configuration
        // See https://smithy.io/2.0/guides/building-codegen/generating-code.html#formatters
        putFormatter('D', SwiftSymbolFormatter(this, shouldSetDefault = true, shouldRenderOptional = true))
        putFormatter('T', SwiftSymbolFormatter(this, shouldSetDefault = false, shouldRenderOptional = true))
        putFormatter('N', SwiftSymbolFormatter(this, shouldSetDefault = false, shouldRenderOptional = false))
    }
}

enum class SwiftDeclaration(
    val keyword: String,
) {
    STRUCT("struct"),
    CLASS("class"),
    ENUM("enum"),
    PROTOCOL("protocol"),
    TYPEALIAS("typealias"),
    FUNC("func"),
    LET("let"),
    VAR("var"),
}
